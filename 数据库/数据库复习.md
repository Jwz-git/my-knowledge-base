**候选码**是能够唯一标识关系中所有元组（即表中的每一行）的一个或一组属性，并且它必须满足“最小性”要求。

如（学号，姓名，年龄，电话号码，...）中，学号能推导出元组里面的所有属性，他是一个候选码。

### 核心定义

一个属性集合 K 要成为关系 R 的候选码，必须同时满足以下两个条件：
1.  **唯一性**：K 的值能唯一确定 R 中的每一个元组。通过一个候选码，你不可能找到两个不同的元组。
2.  **最小性**：K 中没有任何一个属性是多余的。即，K 的任何一个真子集都不能唯一标识元组。

- PS：候选码并不意味着长度一定，如（项目编号，负责人，项目人数，...），其中，一个负责人可负责多个项目，且手下的项目人数各不相同，那么(项目编号)、（负责人，项目人数）都是候选码。

### 重要关系

- **候选码 vs 超码**：超码是满足“唯一性”的属性集，但不一定满足“最小性”。**候选码是最小的超码**。例如，如果 `(学号)` 是候选码，那么 `(学号, 姓名)` 就是一个超码，因为它包含了多余的属性“姓名”。
- **候选码 vs 主键**：一个关系可以有**多个**候选码。数据库设计者会从这些候选码中**选择一个**作为**主键**，用于在数据库中实际组织和管理数据。其他未被选中的候选码则称为**备用键**。
- **候选码vs外码**：外码是别的表的候选码/主码，如（学号，姓名，导员工号，...）、（导员工号，...），前表中的导员工号是外码
---

**主属性**是指包含在任何一个候选码中的属性。

### 核心要点

1.  **定义**：如果某个属性（或字段）是关系R的**某个候选码的组成部分**，那么它就是主属性。
2.  **非主属性**：反之，**不包含在任何候选码中**的属性，就称为**非主属性**。

### 举例说明

假设学生表：`学号`、`身份证号`、`姓名`、`学院`。

- **候选码分析**：
    - 候选码1：`学号`
    - 候选码2：`身份证号`
- **主属性**：`学号` 和 `身份证号`。因为它们各自是一个候选码，都处于候选码集合中。
- **非主属性**：`姓名` 和 `学院`。因为它们不属于任何一个候选码。

**稍微复杂一点的例子**：
假设有一个“选课”关系，记录哪个学生选了哪门课，包含属性：`学号`、`课程号`、`成绩`、`教师`。
- 假设`(学号, 课程号)` 这个属性组合才能唯一确定一条记录（一个学生的一门课成绩），那么它就是**唯一的候选码**（也是主键）。
- **主属性**：`学号` 和 `课程号`，因为它们共同组成了候选码。
- **非主属性**：`成绩` 和 `教师`。

---
### 1. 基本定义
**函数依赖** 指的是在一个关系模式（表）中，一组属性的值可以唯一地决定另一组属性的值。
- 形式化表示为：$X \rightarrow Y$
- 含义：在关系R的任意两个元组（行）中，如果它们在属性集X上的值相等，那么它们在属性集Y上的值也必定相等。
- 解读：**X决定Y**，或称**Y函数依赖于X**。

### 2. 示例说明
假设有一个学生选课关系 `SC(Sno, Sname, Cno, Cname, Grade)`，其中：
- `Sno`: 学号
- `Sname`: 学生姓名
- `Cno`: 课程号
- `Cname`: 课程名
- `Grade`: 成绩

根据常识，我们可以得到以下函数依赖：
- `Sno → Sname`：一个学号唯一对应一个学生姓名。
- `Cno → Cname`：一个课程号唯一对应一个课程名称。
- `(Sno, Cno) → Grade`：一个学生（学号）选修一门特定的课程（课程号），会得到一个特定的成绩。
- `(Sno, Cno) → Sname` 和 `(Sno, Cno) → Cname` 也成立，但这不是“最小”的依赖。

### 3. 关键概念与类型
1. **完全函数依赖**
   - 定义：在 `X → Y` 中，如果Y依赖于X的**全部**属性，而不是X的任何一个真子集，则称Y**完全函数依赖**于X。
   - 示例：在关系SC中，`(Sno, Cno) → Grade` 是完全函数依赖。因为仅凭 `Sno` 或仅凭 `Cno` 都无法决定 `Grade`，必须两者组合才能决定。

2. **部分函数依赖**
   - 定义：在 `X → Y` 中，如果Y可以依赖于X的**某个真子集**，则称Y**部分函数依赖**于X。
   - 示例：在关系SC中，`(Sno, Cno) → Sname` 是部分函数依赖。因为仅凭 `Sno`（它是`(Sno, Cno)`的一个真子集）就足以决定 `Sname` 了。
   - **问题**：部分依赖是导致数据冗余（如学生姓名被重复存储多次）和更新异常的主要原因之一。

3. **传递函数依赖**
   - 定义：如果存在 `X → Y`，`Y → Z`，且 $Y \nrightarrow X$（即Y不决定X），$Z \not\subseteq Y$，那么称Z**传递函数依赖**于X。
   - 示例：在一个关系 `Stu(Sno, Dno, Dname)` 中，有 `Sno → Dno` 和 `Dno → Dname`，且 `Dno` 不决定 `Sno`。那么 `Dname` 就传递依赖于 `Sno`。
   - **问题**：传递依赖同样是数据冗余（如系名随每个学生重复存储）和更新异常的根源。

### 4.平凡和非平凡函数依赖

|特性|平凡函数依赖|非平凡函数依赖|
|:--|:--|:--|
|**定义条件**|||
|**信息价值**|必然成立，无实际约束意义|表达了有意义的语义约束|
|**数据库设计中的角色**|被忽略，不参与规范化分析|**核心分析对象**，是发现冗余、进行规范化的依据|
|**示例**|`{学号, 姓名} -> {学号}`|`学号 -> 院系`|

---
### **第一范式**（1NF）

**定义**：一个关系模式 $R$ 中的所有属性都是**原子的、不可再分**的，并且每个元组的每个属性都有且仅有一个值。

**简单理解**：你的表看起来必须是一个规整的二维表格，不能有“一列多值”或者“表中表”的情况。

*   **示例**：在“学生”表中，如果有一个“联系方式”字段，里面同时存放了手机号和邮箱（如 `"13900001111; a@b.com"`），这就不符合 1NF。正确的做法是将“联系方式”拆分为“手机号”和“邮箱”两个独立的属性。


### **第二范式**（2NF）

**定义**：在满足 1NF 的基础上，**所有非主属性必须完全依赖于整个候选码，而不能仅依赖于候选码的一部分**。

**简单理解**：这主要针对**联合主键**（多个属性菜呢个唯一标识一个元组）的表。一个表里的信息，要么完整地描述主键所代表的“一件事”，要么就单独成表。

*   **示例（基于你的选课表）**：
    *   表：`选课(学号, 课程号, 成绩, 课程名称, 课程学分)`
    *   候选码是 `(学号, 课程号)`，主属性是“学号”和“课程号”。
    *   **问题**：“成绩”完全依赖于候选码 `(学号, 课程号)`（一个学生的一门课对应一个成绩）。但“课程名称”和“课程学分”**只依赖于“课程号”**（候选码的一部分）。
    *   这种“部分函数依赖”会导致数据冗余（同一门课的学分在每条选课记录里重复出现）和更新异常（修改一门课的学分需要更新所有相关记录）。
*   **解决方法（满足2NF）**：将表拆分为：
    *   `选课(学号, 课程号, 成绩)` -- 完全依赖于整个候选码。
    *   `课程(课程号, 课程名称, 课程学分)` -- “课程号”本身是候选码。
    *   把部分依赖的函数关系`X->Y`中的`X，Y`单独拿出来开一个表`(X,Y)`

### **第三范式**（3NF）

**定义**：在满足 2NF 的基础上，**所有非主属性之间不能存在传递函数依赖**(主->非1->非2)。即，非主属性必须直接依赖于候选码，而不能通过另一个非主属性间接依赖。

**简单理解**：一个表里只描述一件与主键直接相关的事，不要顺带描述另一件间接相关的事。

*   **示例**：
    *   表：`学生(学号, 姓名, 学院编号, 学院名称, 学院地址)`
    *   候选码是 `学号`，主属性是“学号”，非主属性是"姓名", "学院编号", "学院名称", "学院地址"。
    *   **问题**：“学院名称”和“学院地址”**依赖于“学院编号”**，而“学院编号”又依赖于“学号”。这就形成了 `学号 -> 学院编号 -> (学院名称, 学院地址)` 的传递依赖。
    *   这同样会导致冗余（同一学院的信息在每个学生记录里重复）和更新异常。
*   **解决方法（满足3NF）**：将表拆分为：
    *   `学生(学号, 姓名, 学院编号)` -- 直接依赖于候选码。
    *   `学院(学院编号, 学院名称, 学院地址)` -- “学院编号”本身是候选码。
    *   把非主属性之间的传递依赖`非1->非2`,拿出来开一个表`(非1，非2)`,原表中的`非1`,当外码。

### **BC范式**（BCNF）

**定义**：在满足 3NF 的基础上，**对于关系模式 $R$ 中存在的每一个非平凡的函数依赖 $X \rightarrow Y(Y \not\subset X)$， $X$ 都必须包含一个候选码**。
若ABC是候选码，但是存在函数依赖AB->D，那么不是BCNF

**简单理解**：BCNF 是比 3NF 更严格的标准。它要求**所有能决定其他属性的属性集合（决定因素），都必须是候选码**。

*   **关键点**：3NF 允许“主属性”对非主属性有依赖，而 BCNF 不允许。
-  **示例**：
	*   **表**：`选课(学号, 课程, 教师)`
	*   **业务规则**：
	    1.  一位教师只教授一门固定课程（即教师决定课程）。
	    2.  一门课程可以由多位教师教授。
	    3.  每个学生选修的每门课程，都固定由一位教师授课（即学生和课程共同决定教师）。
	*   **函数依赖**：
	    1.  `(学号, 课程) -> 教师`
	    2.  `教师 -> 课程`
	*   **候选码**：有两个：`(学号, 课程)` 和 `(学号, 教师)`。
	*   **BCNF分析**：存在函数依赖 `教师 -> 课程`，但它的决定因素“教师”**不是候选码**（因为教师不能唯一标识整个元组，即教师不是超键）。这违反了BCNF，会导致更新异常：如果一位教师更换所教课程，则需要修改多个元组。
*   **解决方法（满足BCNF）**：将表拆分为：
    *   `教师课程(教师, 课程)` — `教师` 为候选码。
    *   `学生教师(学号, 教师)` — `(学号, 教师)` 为候选码。
    *   与之前的差不多，也是单独开一个表

### **总结关系**

它们是一个逐级包含的关系：
**1NF $\subset$ 2NF $\subset$ 3NF $\subset$ BCNF**

简单记忆：
*   **1NF**：属性原子。
*   **2NF**：消除非主属性对码的**部分函数依赖**。
*   **3NF**：消除非主属性对码的**传递函数依赖**。
*   **BCNF**：消除主属性对码的**部分和传递函数依赖**（所有决定因素都必须是候选码）。

如果一个表**没有非主属性**，那么它最少是**3NF**

---


